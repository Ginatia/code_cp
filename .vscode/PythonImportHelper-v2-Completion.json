[
    {
        "label": "heapq",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "heapq",
        "description": "heapq",
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "first_true",
        "kind": 2,
        "importPath": "python.binary_answer",
        "description": "python.binary_answer",
        "peekOfCode": "def first_true(L: int, R: int, f):\n    R += 1\n    while L < R:\n        mid = L+(R-L)//2\n        if f(mid):\n            R = mid\n        else:\n            L = mid+1\n    return L\ndef last_true(L: int, R: int, f):",
        "detail": "python.binary_answer",
        "documentation": {}
    },
    {
        "label": "last_true",
        "kind": 2,
        "importPath": "python.binary_answer",
        "description": "python.binary_answer",
        "peekOfCode": "def last_true(L: int, R: int, f):\n    L -= 1\n    while L < R:\n        mid = L+(R-L+1)//2\n        if f(mid):\n            L = mid\n        else:\n            R = mid-1\n    return L\ndef test():",
        "detail": "python.binary_answer",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "python.binary_answer",
        "description": "python.binary_answer",
        "peekOfCode": "def test():\n    a = list(range(10))\n    def even(i):\n        return a[i] % 2 == 0\n    print(first_true(0, 10, even), last_true(0, 10, even))\ntest()",
        "detail": "python.binary_answer",
        "documentation": {}
    },
    {
        "label": "Dijkstra",
        "kind": 6,
        "importPath": "python.dijkstra",
        "description": "python.dijkstra",
        "peekOfCode": "class Dijkstra:\n    def __init__(self, _n: int) -> None:\n        self.G = [[] for _ in range(_n)]\n        self.bs = [-1]*_n\n    def add_edge(self, u: int, v: int, c):\n        self.G[u].append((v, c))\n    def build(self, s: int, INF):\n        n = len(self.G)\n        ds = [INF]*n\n        ds[s] = 0",
        "detail": "python.dijkstra",
        "documentation": {}
    },
    {
        "label": "Dsu",
        "kind": 6,
        "importPath": "python.Dsu",
        "description": "python.Dsu",
        "peekOfCode": "class Dsu:\n    def __init__(self, n: int) -> None:\n        self.f = list(range(n))\n        self.sz = [1]*n\n    def leader(self, x: int) -> int:\n        x_copy = x\n        while x != self.f[x]:\n            x = self.f[x]\n        while x_copy != x:\n            self.f[x_copy], x_copy = x, self.f[x_copy]",
        "detail": "python.Dsu",
        "documentation": {}
    },
    {
        "label": "z_func",
        "kind": 2,
        "importPath": "python.string",
        "description": "python.string",
        "peekOfCode": "def z_func(s: str) -> list:\n    n = len(s)\n    z = [0]*(n)\n    l, r = 0, 0\n    for i in range(1, n):\n        if i < r:\n            z[i] = min(r-i, z[i-l])\n        while i+z[i] < n and s[z[i]] == s[i+z[i]]:\n            z[i] += 1\n        if i+z[i] > r:",
        "detail": "python.string",
        "documentation": {}
    },
    {
        "label": "find_position",
        "kind": 2,
        "importPath": "python.string",
        "description": "python.string",
        "peekOfCode": "def find_position(t: str, p: str) -> list:\n    \"\"\"\n    t:text string,p:pattern string\n    from t find p\n    \"\"\"\n    idx = []\n    Lt, Lp = len(t), len(p)\n    s = p+\"#\"+t\n    z = z_func(s)\n    for i in range(Lt):",
        "detail": "python.string",
        "documentation": {}
    },
    {
        "label": "prefix_func",
        "kind": 2,
        "importPath": "python.string",
        "description": "python.string",
        "peekOfCode": "def prefix_func(s: str) -> list:\n    n = len(s)\n    pi = [0]*n\n    for i in range(1, n):\n        j = pi[i-1]\n        while j > 0 and s[i] != s[j]:\n            j = pi[j-1]\n        if s[i] == s[j]:\n            j += 1\n        pi[i] = j",
        "detail": "python.string",
        "documentation": {}
    },
    {
        "label": "match",
        "kind": 2,
        "importPath": "python.string",
        "description": "python.string",
        "peekOfCode": "def match(t: str, p: str) -> bool:\n    \"\"\"\n    t:text string,p:pattern string\n    from t find p\n    \"\"\"\n    lps = prefix_func(p+'#'+t)\n    Lt, Lp = len(t), len(p)\n    for i in range(Lp+1, Lt+Lp+1):\n        if lps[i] == Lp:\n            return True",
        "detail": "python.string",
        "documentation": {}
    }
]